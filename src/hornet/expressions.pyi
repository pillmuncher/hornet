from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Callable, Protocol

from .terms import Atom, DCGRule, Functor, Rule, Term


def unital(func: Callable[..., Term]) -> Callable[..., Expression]: ...


def promote(obj: Any) -> Term: ...


class HasTerm[T](Protocol):
    @property
    def term(self) -> T: ...


@dataclass(frozen=True, slots=True)
class RuleExpression[T]:
    term: T


@dataclass(frozen=True, slots=True)
class DCG:
    term: Atom | Functor

    def when(self, *args) -> RuleExpression[DCGRule]: ...


@dataclass(frozen=True, slots=True)
class Expression[T: Term]:
    term: T

    def __init__(self, term: Term): ...
    def when(self, *args: Any) -> RuleExpression[Rule]: ...
    def __neg__(self: Any): ...
    def __pos__(self: Any): ...
    def __invert__(self: Any): ...
    def __add__(self: Any, other: Any): ...
    def __radd__(self: Any, other: Any): ...
    def __sub__(self: Any, other: Any): ...
    def __rsub__(self: Any, other: Any): ...
    def __mul__(self: Any, other: Any): ...
    def __rmul__(self: Any, other: Any): ...
    def __truediv__(self: Any, other: Any): ...
    def __rtruediv__(self: Any, other: Any): ...
    def __floordiv__(self: Any, other: Any): ...
    def __rfloordiv__(self: Any, other: Any): ...
    def __mod__(self: Any, other: Any): ...
    def __rmod__(self: Any, other: Any): ...
    def __pow__(self: Any, other: Any): ...
    def __rpow__(self: Any, other: Any): ...
    def __lshift__(self: Any, other: Any): ...
    def __rlshift__(self: Any, other: Any): ...
    def __rshift__(self: Any, other: Any): ...
    def __rrshift__(self: Any, other: Any): ...
    def __and__(self: Any, other: Any): ...
    def __rand__(self: Any, other: Any): ...
    def __xor__(self: Any, other: Any): ...
    def __rxor__(self: Any, other: Any): ...
    def __or__(self: Any, other: Any): ...
    def __ror__(self: Any, other: Any): ...
    def __call__(self: Any, *args: Any): ...
